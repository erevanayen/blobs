<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>
<style>
    body {
        margin: 0;
    }
    canvas {
        width: 100vw;
        height: 100vh;
        display: block;
    }
</style>
<body>
    <canvas id="myCanvas"></canvas>
    <script type="module">
        import * as THREE from "https://cdn.jsdelivr.net/npm/three@v0.149.0/build/three.module.js"
        import { frame } from "https://cdn.jsdelivr.net/npm/motion@12.11.0/+esm"

        const fragmentShaderSource = `
#include <common>
precision mediump float;
uniform vec3 iResolution;
uniform float uTime, uAnimSpeed, uFOV;
int it=120;
float dt=.001,st=100.,contrast=1.0;
float sdS(vec3 p,float s){return length(p)-s;}
float smin(float a,float b,float k){float h=max(k-abs(a-b),0.0)/k;return min(a,b)-h*h*h*k*(1.0/6.0);}
mat2 rot2D(float angle){float s=sin(angle);float c=cos(angle);return mat2(c, -s, s, c);}
float map(vec3 p,float speedRot,float sphereSize){vec3 spherePos = vec3(sin(uTime/5.*speedRot)*2.,sin(uTime/2.*speedRot)*0.5-0.8,sin(uTime/3.*speedRot)*1.5);float sphere = sdS(p-spherePos,sphereSize);vec3 spherePos2 = vec3(sin(uTime/4.*speedRot-3.14159)*2.,sin(uTime/1.5*speedRot)*0.5-0.8,sin(uTime/2.*speedRot-3.14159)*1.5);float sphere2 = sdS(p-spherePos2,sphereSize);float ground = p.y+.25;return smin(ground,smin(sphere,sphere2,2.),4.);}
float bO(float a,float b){return a<.5 ? (2.*a*b) : (1.-2.*(1.-a)*(1.-b));}
vec4 bmOverlay(vec4 a, vec4 b){return vec4(bO(a.r, b.r), bO(a.g, b.g), bO(a.b, b.b), a.a);}
vec4 bmAlphaOverlay(vec4 a, vec4 b, float opacity){return (bmOverlay(a, b) * opacity + b * (1. - opacity));}
vec3[4] gradGr1=vec3[](vec3(0.,.255,.212),vec3(.008,.557,.498),vec3(.549,.773,.247),vec3(.2));
vec3[4] gradGr2=vec3[](vec3(.549,.773,.247),vec3(.008,.557,.498),vec3(0.,.255,.212),vec3(.2));
vec3 gp(float t, vec3[4] usedGradient){float scaledT = t / (st*0.01);float mcp = usedGradient[3].x;vec3 resultColor = mix(mix(usedGradient[0], usedGradient[1], scaledT/mcp),mix(usedGradient[1], usedGradient[2], (scaledT - mcp) / (1.0 - mcp)),step(mcp, scaledT));return resultColor;}
vec4 blobScene(vec2 uv, float sphereSize, vec3 camRot, float camDist, float speedRot, vec3[4] usedGradient, float timeOffset){
  vec4 sceneOut = vec4(0.0);
  vec3 ro=vec3(0.,0.,-camDist),rd=normalize(vec3(uv * uFOV, 1.)),col=vec3(0.0);
  float t=0.;
  ro.yz*=rot2D(camRot.x);
  rd.yz*=rot2D(camRot.x);
  int i;
  for (i=0;i<it;i++) {
    vec3 p=ro+rd*t;float d=map(p,speedRot,sphereSize);t+=d;if (d<dt) break;if (t>st) break;
  }
  col = gp((t*.04+float(i)*0.005)*contrast, usedGradient);
  sceneOut = vec4(col,1.);
  return sceneOut;
}
void main(){
  vec2 uv=(gl_FragCoord.xy*2.-iResolution.xy)/iResolution.y;
  vec4 scene1=blobScene(uv,1.0,vec3(1.,0.6,0.),2.2,uAnimSpeed,gradGr1,0.),scene2=blobScene(uv,1.3,vec3(1.2,0.7,0.),3.2,uAnimSpeed*-2.,gradGr2,10.);
  gl_FragColor = bmAlphaOverlay(scene1, scene2, abs(sin(uTime/8.))*1.);
}
        `;

        const canvas = document.getElementById('myCanvas');
        const camera = new THREE.OrthographicCamera(
            -1, // left
            1, // right
            1, // top
            -1, // bottom
            -1, // near,
            1, // far
        );
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            canvas: canvas,
        });
        renderer.autoClearColor = false;

        // uniforms for the shader
        const uniforms = {
            uTime: { value: 0 },
            uAnimSpeed: { value: .2 },
            uFOV: { value: 0.5 },
            iResolution: { value: new THREE.Vector3() },
        };

        const scene = new THREE.Scene();
        const plane = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            fragmentShader: fragmentShaderSource,
            uniforms,
        });
        scene.add(new THREE.Mesh(plane, material));

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        function resizeCanvas() {
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', resizeCanvas);

        function updateFrame() {
            var time = performance.now();
            uniforms.uTime.value = time * 0.001; // set time to seconds
            uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
            renderer.render(scene, camera);
        }
        frame.update(updateFrame, true);
    </script>
</body>
</html>