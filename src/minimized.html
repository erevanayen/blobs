<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>
<style>
    body {
        margin: 0;
    }
    canvas {
        width: 100vw;
        height: 100vh;
        display: block;
    }
</style>
<body>
    <canvas id="myCanvas"></canvas>
    <script type="module">
        import * as THREE from "https://cdn.jsdelivr.net/npm/three@v0.149.0/build/three.module.js"
        import { frame } from "https://cdn.jsdelivr.net/npm/motion@12.11.0/+esm"

        const fragmentShaderSource = `
#include <common>
precision mediump float;
uniform vec3 iResolution;
uniform float uTime, uAnimSpeed, uFOV;
const vec3 f=vec3(.008,.557,.498),s=vec3(.549,.773,.247),u=vec3(0,.255,.212);float n(vec3 u,float m){return length(u)-m;}float n(float u,float f,float m){float s=max(m-abs(u-f),0.)/m;return min(u,f)-s*s*s*m*(1./6.);}mat2 n(float f){float s=sin(f);f=cos(f);return mat2(f,-s,s,f);}float n(vec3 u,float f,float s){float m=sin(uTime/8.*f)*.9;vec3 v=vec3(sin(uTime/5.*f)*2.,sin(uTime/2.*f)*.5-.2,sin(uTime/3.*f)*1.5),V=vec3(sin(uTime/4.*f-3.14159)*2.,sin(uTime/1.5*f)*.5-.8,sin(uTime/2.*f-3.14159)*1.5);return n(u.y+.25+sin(m*u.x)*sin(m*u.y)*sin(m*u.z)*.25,n(n(u-v,s),n(u-V,s),5.),4.);}float n(float f,float s){return f<.5?2.*f*s:1.-2.*(1.-f)*(1.-s);}vec3 v(float m){vec3 v[4]=vec3[4](u,f,s,u);float n[4]=float[4](.05,.2,.3,sin(uTime*.1)*.15+.4+.15);for(int f=0;f<4;f++)if(m<=n[f]){float s=n[f-1],u=n[f];return mix(v[f-1],v[f],(m-s)/(u-s));}return v[3];}vec4 n(vec2 u,float f,vec3 m,float s,float V,float x){vec3 r=vec3(0,1,-s),i=normalize(vec3(u*uFOV,1)),d=vec3(0);s=0.;r.yz*=n(m.x);i.yz*=n(m.x);int y;for(y=0;y<120;y++){vec3 u=r+i*s;float m=n(u,V,f);s+=m;if(m<.001)break;if(s>1e2)break;}d=v(s*.04+float(y)*.005);return vec4(d,1);}void main(){vec2 u=(gl_FragCoord.xy*2.-iResolution.xy)/iResolution.y;vec4 f=n(u,1.,vec3(.7,.6,0),3.,uAnimSpeed,0.),s=n(u,1.3,vec3(.8,.7,0),2.2,uAnimSpeed*-2.,10.);gl_FragColor=vec4(n(s.x,f.x),n(s.y,f.y),n(s.z,f.z),s.w)*.1+f*.9;}
        `;

        const timeOffset = 1000.0;
        const canvas = document.getElementById('myCanvas');
        const camera = new THREE.OrthographicCamera(
            -1, // left
            1, // right
            1, // top
            -1, // bottom
            -1, // near,
            1, // far
        );
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            canvas: canvas,
        });
        renderer.autoClearColor = false;

        // uniforms for the shader
        const uniforms = {
            uTime: { value: 0 },
            uAnimSpeed: { value: .2 },
            uFOV: { value: 0.5 },
            iResolution: { value: new THREE.Vector3() },
        };

        const scene = new THREE.Scene();
        const plane = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            fragmentShader: fragmentShaderSource,
            uniforms,
        });
        scene.add(new THREE.Mesh(plane, material));

        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        function resizeCanvas() {
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', resizeCanvas);

        function updateFrame() {
            var time = performance.now();
            uniforms.uTime.value = time * 0.001 + timeOffset; // set time to seconds
            uniforms.iResolution.value.set(canvas.width, canvas.height, 1);
            renderer.render(scene, camera);
        }
        frame.update(updateFrame, true);
    </script>
</body>
</html>